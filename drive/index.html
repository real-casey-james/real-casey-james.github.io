<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="drive.css">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>

    let sheeps, car, duck, scoreText, carPosX, carPosY, carVelX, carVelY, particles, timer, vision, offsets, rainbowParticles, rainbowParticlesY, planes, dragons, greenDragons
    let hit = false
    let score = 0
    let carVelocity = 300

let Start = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize: 
    
    function start () { Phaser.Scene.call(this, { key: 'start', active: true })},

    preload: function () {
        this.load.audio('shutup', 'assets/sounds/shutup.mp3')
        this.load.audio('engine', 'assets/sounds/engine.wav')
        this.load.script('webfont', 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js');
        this.load.image('button', 'assets/images/ButtonTemplate.png')
        this.load.image('pig', 'assets/images/Pig_Down@2x.png')
        this.load.image('chick', 'assets/images/Chick_Down@2x.png')

        this.load.tilemapTiledJSON('drive', 'assets/maps/drive.json');
        this.load.image("roadEW", "assets/images/roadEW.png")
        this.load.image("roadNE", "assets/images/roadNE.png")
        this.load.image('tiles', 'assets/images/tiles.png')
        this.load.image('car', 'assets/images/Daco_4361360.png')
        this.load.image('star', 'assets/images/star.png')
        this.load.audio('ding', 'assets/sounds/ding.wav')
        this.load.image('scoreBackground', 'assets/images/UI_Toolbar_Top_Corner.png')
        this.load.image('scoreCoin', 'assets/images/scoreCoin.png')

        this.load.spritesheet('tractor', 'assets/images/tractor.png', { frameWidth: 32, frameHeight: 32, margin: 1, spacing: 2 })

        this.load.image('Serene_Village_48x48', 'assets/images/Serene_Village_48x48.png')
        this.load.image('redHouse', 'assets/images/redHouse.png')
        this.load.image('blueHouse', 'assets/images/blueHouse.png')
        this.load.image('greenHouse', 'assets/images/greenHouse.png')
        this.load.image('smallRedHouse', 'assets/images/smallRedHouse.png')
        this.load.image('smallBlueHouse', 'assets/images/smallBlueHouse.png')
        this.load.image('smallGreenHouse', 'assets/images/smallGreenHouse.png')
        this.load.image('trees1', 'assets/images/trees1.png')
        this.load.image('trees2', 'assets/images/trees2.png')
        this.load.image('trees3', 'assets/images/trees3.png')
        this.load.image('smoke', 'assets/images/smoke-puff.png')
        this.load.spritesheet('sheep', 'assets/images/sheep_walk.png', { frameWidth: 128, frameHeight: 128 } )
        this.load.audio('sheepSound', 'assets/sounds/sheep.wav')
        this.load.audio('crash', 'assets/sounds/151624__qubodup__clank-car-crash-collision.wav')
        this.load.image('blood', 'assets/images/blood.png')
        this.load.image('Modern_Office_64x64', 'assets/images/Modern_Office_64x64.png')
        this.load.image('paper', 'assets/images/paper.png')
        this.load.image('cooler', 'assets/images/cooler.png')
        this.load.audio('printer', 'assets/sounds/printer.wav') 
        this.load.image('printerDown', 'assets/images/printerDown.png')
        this.load.image('printerLeft', 'assets/images/printerLeft.png')
        this.load.image('printerRight', 'assets/images/printerRight.png')
        this.load.image('printerUp', 'assets/images/printerUp.png')

        this.load.audio('quack', 'assets/sounds/duckwin.wav')
        this.load.image('bread', 'assets/images/bread.png')
        this.load.spritesheet('duckSprite',
            'assets/images/ducks.png',
            { frameWidth: 48, frameHeight: 48 })
        this.load.image('beachball', 'assets/images/BeachBall.png')
        this.load.image('bush', 'assets/images/Bush.png')
        this.load.image('cat', 'assets/images/Cat_Down.png')
        this.load.image('chick', 'assets/images/Chick_Down.png')
        this.load.image('danger', 'assets/images/Danger_Water.png')
        this.load.image('fox', 'assets/images/Fox_Down.png')
        this.load.image('beetroot', 'assets/images/GardenBed_Beetroot_02.png')
        this.load.image('carrots', 'assets/images/GardenBed_Carrots_02.png')
        this.load.image('cucumbers', 'assets/images/GardenBed_Cucumbers_02.png')
        this.load.image('tomatoes', 'assets/images/GardenBed_Tomatoes_02.png')
        this.load.image('pig', 'assets/images/Pig_Down.png')
        this.load.image('rabbit', 'assets/images/Rabbit_Down.png')
        this.load.image('barrel', 'assets/images/RadioactiveBarrel.png')
        this.load.image('shovel', 'assets/images/Showel.png')
        this.load.image('waterTree', 'assets/images/Tree.png')
        this.load.image('wateringCan', 'assets/images/WateringCan.png')
        this.load.image('SewerTileStraight', 'assets/images/SewerTileStraight.png')
        this.load.image('SewerTileTurn', 'assets/images/SewerTileTurn.png')
        this.load.image('rat', 'assets/images/RatKing.png')
        this.load.image('gator', 'assets/images/Gator.png')
        this.load.image('vision', 'assets/images/radial_gradient.png')
        this.load.image('speaker', 'assets/images/F02.png')
        this.load.image('speakerLeft', 'assets/images/F02 left.png')
        this.load.audio('slurp', 'assets/sounds/slurp.wav')
        this.load.image('transparent', 'assets/images/transparent.png')
        this.load.image('SewerBackground', 'assets/images/SewerBackground.png')
        this.load.spritesheet('redDragon', 'assets/images/redDragon.png', { frameWidth: 191, frameHeight: 161 })
        this.load.spritesheet('greenDragon', 'assets/images/greenDragon.png', { frameWidth: 64, frameHeight: 64 })
        this.load.image('desert', 'assets/images/desert.png')
        this.load.image('durry', 'assets/images/durry.png')
        this.load.audio('exhale', 'assets/sounds/exhale.wav')
        this.load.spritesheet('camel', 'assets/images/camel.png', { frameWidth: 48, frameHeight: 48 } )
        this.load.image('smoke', 'assets/images/smoke-puff.png')
        this.load.image('rainbow', 'assets/images/rainbow.png')
        this.load.image('pyramid', 'assets/images/pyramid.png')
        this.load.image('desertObjects', 'assets/images/desertObjects.png')
        this.load.image('clouds', 'assets/images/clouds.png')
        this.load.image('egg', 'assets/images/gold_egg.png')
        this.load.spritesheet('bird', 'assets/images/skyBird.png', { frameWidth: 192, frameHeight: 174 } )
        this.load.image('farground', 'assets/images/farground.png')
        this.load.image('foreground', 'assets/images/foreground.png')
        this.load.image('skyMid', 'assets/images/skyMid.png')
        this.load.image('sun', 'assets/images/sun.png')
        this.load.image('rainbow', 'assets/images/rainbow.png')
        this.load.audio('harp', 'assets/sounds/harp.wav')
        this.load.image('Rainbow Corner 1', 'assets/images/Rainbow Corner 1.png')
        this.load.image('Rainbow Corner 2', 'assets/images/Rainbow Corner 2.png')
        this.load.image('Seven-colors_(rainbow)', 'assets/images/Seven-colors_(rainbow).png')
        this.load.image('jesus', 'assets/images/jesus.png')
        this.load.image('plane', 'assets/images/plane.png')
        this.load.image('spaceStation', 'assets/images/spaceStation.png')
        this.load.image('gold', 'assets/images/gold.png')

        this.load.image('pig', 'assets/images/Pig_Down@2x.png')
        this.load.image('chick', 'assets/images/Chick_Down@2x.png')
        this.load.image('coin', 'assets/images/CoinNoShadow.png')
        this.load.image('ruby', 'assets/images/Ruby.png')
    },

    create: function () {
        let startItems = this.add.group()
        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            add.text(90, 100, 'SHUT UP AND DRIVE', { fontFamily: 'Fredoka One', fontSize: '62px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 6, offsetX: 3, color: 'white', fill: true} })
            add.text(250, 300, 'SPACE TO START', { fontFamily: 'Fredoka One', fontSize: '32px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} })
        }
    });

        this.add.image(220, 277, 'button').setScale(0.7).setOrigin(0)
        startItems.add(this.add.image(100, 450, 'pig'))
        startItems.add(this.add.image(700, 450, 'chick'))
        startItems.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                }
            })
        })

        let camera = this.cameras.main;
        camera.setBackgroundColor('#8CB7F2')

        this.input.keyboard.once('keydown-SPACE', () => {
            this.cameras.main.fadeOut(100, 255, 255, 255)
        })
        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, (cam, effect) => {
            this.sound.play('shutup')
            this.sound.play('engine')
            this.scene.start('city')
        })
    },

    update: function () {
    }
})

    let City = new Phaser.Class({
        Extends: Phaser.Scene,

        initialize: 

    function cityScene () { Phaser.Scene.call(this, { key: 'city', active: false })},

    preload: function () {
    },
    
    create: function () {

        timer = this.time.addEvent({
            delay: 28300,
            loop: false,
            callback: () => {
                this.cameras.main.fadeOut(100, 255, 255, 255)
            }
        })

        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, (cam, effect) => {
            this.sound.play('engine')
            carPosX = car.body.position.x,
            carPosY = car.body.position.y,
            this.scene.start('sceneA')
        })

        this.physics.world.setBounds(0, 0, 3200, 1920);

        const map = this.make.tilemap({key: 'drive'});   
        const tileset = map.addTilesetImage('roadEW', 'roadEW')
        const tileset2 = map.addTilesetImage('roadNE', 'roadNE')
        const cityTiles = map.addTilesetImage('tiles', 'tiles')
        const allTiles = [tileset, tileset2]
        
        RoofLayer = map.createLayer('Buildings', cityTiles)
        map.createLayer('Road', allTiles)
        let CollisionLayer = map.createLayer('Footpath', allTiles)
        let StarLayer = map.getObjectLayer('Sheep')['objects']

        let stars = this.physics.add.group()
          
        StarLayer.forEach(object => {
            let obj = stars.create(object.x, object.y, 'star')
            obj.setOrigin(-1, 2)
            obj.setSize(50, 50, true)
        })

        car = this.physics.add.image(300, 100, 'car').setScale(0.04)
        car.setSize(1200, 1200, true)
        car.angle = 180
        
        map.setCollisionBetween(0, 923, true, 'Footpath')
        this.physics.add.collider(car, CollisionLayer)
        this.physics.add.overlap(car, stars, hitStar, null, this)

        this.cameras.main.setBounds(0, 0, 3200, 1920);
        this.cameras.main.startFollow(car);
        
        car.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();


        this.add.image(0, 0, 'scoreBackground').setScale(0.55, 0.65).setOrigin(0).setScrollFactor(0)
        this.add.image(40, 25, 'scoreCoin').setScale(0.6).setScrollFactor(0)
        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            scoreText = add.text(70, 12, score, { fontFamily: 'Fredoka One', fontSize: '25px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} }).setScrollFactor(0)
        }
    });

        function hitStar (car, star) {
            this.sound.play('ding')
            star.destroy()
            score += 10;
            carVelocity += 10
            scoreText.setText(score);
        }
        game.events.on('blur', () => {
            timer.paused = true
        })
        game.events.on('focus', () => {
            timer.paused = false
        })
    },

    update: function () {
        if (cursors.left.isDown && cursors.up.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY((carVelocity * -1))
            car.angle = 45
        } else if (cursors.right.isDown && cursors.up.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY((carVelocity * -1))
            car.angle = 135
        } else if (cursors.right.isDown && cursors.down.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY(carVelocity)
            car.angle = 225
        } else if (cursors.left.isDown && cursors.down.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY(carVelocity)
            car.angle = 315
        } else if (cursors.left.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.angle = 0
        } else if (cursors.right.isDown) {
            car.setVelocityX(carVelocity)
            car.angle = 180
        } else if (cursors.up.isDown) {
            car.setVelocityY((carVelocity * -1))
            car.angle = 90
        } else if (cursors.down.isDown) {
            car.setVelocityY(carVelocity)
            car.angle = 270
        } else {
            car.setVelocityX(0)
            car.setVelocityY(0)
        }    
    } 
})

    let Village = new Phaser.Class({
        Extends: Phaser.Scene,

        initialize: 

    function sceneA () { Phaser.Scene.call(this, { key: 'sceneA', active: false })},

    preload: function () {
    },

    create: function () {
        let scoringActive
        this.time.addEvent({
            delay: 500,
            loop: false,
            callback: () => {
                scoringActive = true
            }
        })
        timer = this.time.addEvent({
            delay: 28500,
            loop: false,
            callback: () => {
                this.cameras.main.fadeOut(100, 255, 255, 255)
            }
        })

        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, (cam, effect) => {
            this.sound.play('engine')
            carVelocity = 250
            carPosX = car.body.position.x,
            carPosY = car.body.position.y,
            this.scene.start('cubicle')
        })

        this.physics.world.setBounds(0, 0, 3200, 1920);

        const map = this.make.tilemap({key: 'drive'});   
        const villageTiles = map.addTilesetImage('Serene_Village_48x48', 'Serene_Village_48x48')
        
        map.createLayer('Village Background', villageTiles)
        map.createLayer('Village Road', villageTiles)
        let CollisionLayer = map.createLayer('Village Footpath', villageTiles)
        let SheepLayer = map.getObjectLayer('Sheep')['objects']

        let bloodParticles = this.add.particles('blood')

        car = this.physics.add.sprite(carPosX, carPosY, 'tractor').setScale(3)
        car.setSize(15, 15, true)

        let buildings = this.add.group()
        buildings.add(this.add.image(1473, 620, 'smallRedHouse').setScale(1))
        buildings.add(this.add.image(2008, 1031, 'smallRedHouse').setScale(1))
        buildings.add(this.add.image(2512, 1440, 'smallRedHouse').setScale(1))
        buildings.add(this.add.image(596, 180, 'smallBlueHouse').setScale(1))
        buildings.add(this.add.image(860, 1111, 'smallBlueHouse').setScale(1))
        buildings.add(this.add.image(1299, 651, 'smallBlueHouse').setScale(1))
        buildings.add(this.add.image(2040, 400, 'smallBlueHouse').setScale(1))
        buildings.add(this.add.image(2423, 548, 'smallBlueHouse').setScale(1))
        buildings.add(this.add.image(788, 485, 'smallGreenHouse').setScale(1))
        buildings.add(this.add.image(1660, 651, 'smallGreenHouse').setScale(1))
        buildings.add(this.add.image(2040, 727, 'smallGreenHouse').setScale(1))
        buildings.add(this.add.image(2800, 213, 'smallGreenHouse').setScale(1))
        buildings.add(this.add.image(1251, 216, 'blueHouse').setScale(1))
        buildings.add(this.add.image(1600, 1030, 'blueHouse').setScale(1))
        buildings.add(this.add.image(2916, 1623, 'blueHouse').setScale(1))
        buildings.add(this.add.image(865, 216, 'redHouse').setScale(1))
        buildings.add(this.add.image(1100, 1109, 'redHouse').setScale(1))
        buildings.add(this.add.image(2688, 1048, 'redHouse').setScale(1))
        buildings.add(this.add.image(1637, 215, 'greenHouse').setScale(1))
        buildings.add(this.add.image(548, 1111, 'greenHouse').setScale(1))
        buildings.add(this.add.image(1956, 1429, 'greenHouse').setScale(1))
        buildings.add(this.add.image(260, 220, 'trees1').setScale(1))
        buildings.add(this.add.image(580, 925, 'trees1').setScale(1))
        buildings.add(this.add.image(200, 1500, 'trees1').setScale(1))
        buildings.add(this.add.image(1025, 1500, 'trees1').setScale(1))
        buildings.add(this.add.image(1900, 1692, 'trees1').setScale(1))
        buildings.add(this.add.image(580, 1500, 'trees2').setScale(1))
        buildings.add(this.add.image(1091, 925, 'trees2').setScale(1))
        buildings.add(this.add.image(2370, 160, 'trees2').setScale(1))
        buildings.add(this.add.image(1924, 220, 'trees2').setScale(1))
        buildings.add(this.add.image(2433, 1236, 'trees3').setScale(1))
        buildings.add(this.add.image(20, 930, 'trees3').setScale(1)).setOrigin(0,0)
        buildings.add(this.add.image(1411, 1500, 'trees3').setScale(1)).setOrigin(0,0)

        buildings.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                }
            })
        })
        
        sheeps = this.physics.add.group()
        
        this.anims.create ({
            key: 'up',
            frames: this.anims.generateFrameNumbers('sheep', { start: 0, end: 3 }),
            frameRate: 17.65,
            repeat: -1
        })

        this.anims.create ({
            key: 'left',
            frames: this.anims.generateFrameNumbers('sheep', { start: 4, end: 7 }),
            frameRate: 17.65,
            repeat: -1
        })

        this.anims.create ({
            key: 'down',
            frames: this.anims.generateFrameNumbers('sheep', { start: 8, end: 11 }),
            frameRate: 17.65,
            repeat: -1
        })

        this.anims.create ({
            key: 'right',
            frames: this.anims.generateFrameNumbers('sheep', { start: 12, end: 15 }),
            frameRate: 17.65,
            repeat: -1
        })
        
        this.anims.create ({
            key: 'tractorUp',
            frames: this.anims.generateFrameNumbers('tractor', { start: 14, end: 20 }),
            frameRate: 17.65,
            repeat: -1
        })

        this.anims.create ({
            key: 'tractorLeft',
            frames: this.anims.generateFrameNumbers('tractor', { start: 7, end: 13 }),
            frameRate: 17.65,
            repeat: -1
        })

        this.anims.create ({
            key: 'tractorDown',
            frames: this.anims.generateFrameNumbers('tractor', { start: 0, end: 6 }),
            frameRate: 17.65,
            repeat: -1
        })

        this.anims.create ({
            key: 'tractorRight',
            frames: this.anims.generateFrameNumbers('tractor', { start: 7, end: 13 }),
            frameRate: 17.65,
            repeat: -1
        })

        this.anims.create ({
            key: 'tractorStop',
            frames: [{ key: 'tractor', frame: 0 }],
            frameRate: 20,
        })
    
        SheepLayer.forEach(object => {
            let obj = sheeps.create(object.x, object.y, 'sheep')
            obj.setOrigin(0, 1)
            obj.setSize(50, 50, true)
            obj.setVelocity(Phaser.Math.Between(-20, 20), Phaser.Math.Between(-20, 20))
            obj.setBounce(1)
        })

        map.setCollisionBetween(0, 923, true, 'Footpath')
        this.physics.add.collider(car, CollisionLayer)
        this.physics.add.collider(sheeps, CollisionLayer)
        this.physics.add.overlap(car, sheeps, hitSheep, null, this)

        this.cameras.main.setBounds(0, 0, 3200, 1920);
        this.cameras.main.startFollow(car);
        
        car.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();

        this.add.image(0, 0, 'scoreBackground').setScale(0.55, 0.65).setOrigin(0).setScrollFactor(0)
        this.add.image(40, 25, 'scoreCoin').setScale(0.6).setScrollFactor(0)
        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            scoreText = add.text(70, 12, score, { fontFamily: 'Fredoka One', fontSize: '25px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} }).setScrollFactor(0)
        }
    });
    
    particles = this.add.particles('smoke')
    particles.createEmitter({
        lifespan: 1000,
        speedY: -100,
        quantity: 1,
        scale: { start: 0.1, end: 1},
        alpha: { start: 0.5, end: 0 },
        on: false
    })
    
    bloodParticles.createEmitter({
        lifespan: 30000,
        speed: 0,
        quantity: 1,
        scale: 0.2,
        on: false
    })

    function hitSheep (car, sheep) {
            sheep.disableBody(true, true)
            bloodParticles.emitParticleAt((car.body.position.x + 50), (car.body.position.y + 50))
            this.sound.play('sheepSound', { volume: 0.6 })
            this.sound.play('crash', { volume: 0.5 })
            score += 10;
            if (scoringActive) {
                scoreText.setText(score);
            }
            if (sheeps.countActive(true) === 3) {
                sheeps.children.iterate(function (child) {
                    child.enableBody(true, child.x, child.y, true, true);
                });
            }
    }
        game.events.on('blur', () => {
            timer.paused = true
        })
        game.events.on('focus', () => {
            timer.paused = false
        })
    },

    update: function () {
            if (cursors.left.isDown && cursors.up.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY((carVelocity * -1))
            particles.emitParticleAt((car.body.position.x + 70), (car.body.position.y + 70))
        } else if (cursors.right.isDown && cursors.up.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY((carVelocity * -1))
            particles.emitParticleAt((car.body.position.x + 0), (car.body.position.y + 70))
        } else if (cursors.right.isDown && cursors.down.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY(carVelocity)
            particles.emitParticleAt(car.body.position.x, (car.body.position.y + 0))
        } else if (cursors.left.isDown && cursors.down.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY(carVelocity)
            particles.emitParticleAt((car.body.position.x + 70), (car.body.position.y + 0))
        } else if (cursors.left.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.anims.play('tractorLeft', true)
            car.flipX = true
            particles.emitParticleAt((car.body.position.x - 18), (car.body.position.y - 20))
        } else if (cursors.right.isDown) {
            car.setVelocityX(carVelocity)
            car.anims.play('tractorRight', true)
            car.flipX = false
            particles.emitParticleAt((car.body.position.x + 53), (car.body.position.y - 18))
        } else if (cursors.up.isDown) {
            car.setVelocityY((carVelocity * -1))
            car.anims.play('tractorUp', true)
            car.flipX = false
            particles.emitParticleAt((car.body.position.x + 45), (car.body.position.y))
        } else if (cursors.down.isDown) {
            car.setVelocityY(carVelocity)
            car.anims.play('tractorDown', true)
            car.flipX = false
            particles.emitParticleAt((car.body.position.x + 8), (car.body.position.y + 18))
        } else {
            car.setVelocityX(0)
            car.setVelocityY(0)
        }  
        sheeps.children.entries.forEach(sheep => {
            if (sheep.body.velocity.x > 0) {
                sheep.anims.play('right', true)
            } else if (sheep.body.velocity.x < 0) {
                sheep.anims.play('left', true)
            } else if (sheep.body.velocity.y > 0) {
                sheep.anims.play('down', true)
            } else if (sheep.body.velocity.y < 0) {
                sheep.anims.play('up', true)
            }
        })
    }
})

let Cubicle = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize:

    function cubicleScene () { Phaser.Scene.call(this, { key: 'cubicle', active: false })},

    preload: function () {

    },

    create: function () {
        let scoringActive
        let coolerBounce = 1
        this.time.addEvent({
            delay: 500,
            loop: false,
            callback: () => {
                scoringActive = true
            }
        })
        timer = this.time.addEvent({
            delay: 28800,
            loop: false,
            callback: () => {
                this.cameras.main.fadeOut(100, 255, 255, 255)
            }
        })

        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, (cam, effect) => {
            this.sound.play('engine')
            carPosX = car.body.position.x,
            carPosY = car.body.position.y,
            this.scene.start('water')
        })

        this.physics.world.setBounds(0, 0, 3200, 1920)

        const map = this.make.tilemap({key: 'drive'})

        const officeTiles = map.addTilesetImage('Modern_Office_64x64', 'Modern_Office_64x64')

        const tileset = map.addTilesetImage('roadEW', 'roadEW')
        const tileset2 = map.addTilesetImage('roadNE', 'roadNE')
        const allTiles = [tileset, tileset2]

        map.createLayer('Office Background', officeTiles)
        map.createLayer('Office Objects', officeTiles)
        map.createLayer('Office Road', officeTiles)

        car = this.physics.add.sprite(carPosX, carPosY, 'printerDown').setScale(0.2)
        car.setSize(500, 300, true)

        this.anims.create({ key: 'printerUp', frames: [{ key: 'printerUp' }], repeat: -1})
        this.anims.create({ key: 'printerDown', frames: [{ key: 'printerDown' }], repeat: -1})
        this.anims.create({ key: 'printerLeft', frames: [{ key: 'printerLeft' }], repeat: -1})
        this.anims.create({ key: 'printerRight', frames: [{ key: 'printerRight' }], repeat: -1})

        map.createLayer('OfficePath', officeTiles)
        map.createLayer('Office Desk Objects', officeTiles)
        let CollisionLayer = map.createLayer('Footpath', allTiles)
        CollisionLayer.setAlpha(0)

        let StarLayer = map.getObjectLayer('Sheep')['objects']
        let waterCoolers = map.getObjectLayer('Office Water Coolers')['objects']

        let coolers = this.add.group()
        let stars = this.physics.add.group()
          
        StarLayer.forEach(object => {
            let obj = stars.create(object.x, object.y, 'paper')
            obj.setOrigin(-1, 2)
            obj.setSize(150, 150, true)
            obj.setScale(0.3)
        })

        waterCoolers.forEach(object => {
            let obj = coolers.add(this.add.image(object.x, object.y, 'cooler'))
            obj.setOrigin(0.5, 0.1)
        })     

        map.setCollisionBetween(0, 923, true, 'Footpath')
        this.physics.add.collider(car, CollisionLayer)
        this.physics.add.overlap(car, stars, hitStar, null, this)

        this.cameras.main.setBounds(0, 0, 3200, 1920);
        this.cameras.main.startFollow(car);
        
        car.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();
        this.add.image(0, 0, 'scoreBackground').setScale(0.55, 0.65).setOrigin(0).setScrollFactor(0)
        this.add.image(40, 25, 'scoreCoin').setScale(0.6).setScrollFactor(0)
        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            scoreText = add.text(70, 12, score, { fontFamily: 'Fredoka One', fontSize: '25px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} }).setScrollFactor(0)
        }
    });

        function hitStar (copierA, star) {
            this.sound.play('printer')
            star.destroy()
            score += 10;
            carVelocity += 20
            if (scoringActive) {
                scoreText.setText(score);
            }
        }

        coolers.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                }
            })
        })
        game.events.on('blur', () => {
            timer.paused = true
        })
        game.events.on('focus', () => {
            timer.paused = false
        })
    },

    update: function () {
        if (cursors.left.isDown && cursors.up.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY((carVelocity * -1))
        } else if (cursors.right.isDown && cursors.up.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY((carVelocity * -1))
        } else if (cursors.right.isDown && cursors.down.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY(carVelocity)
        } else if (cursors.left.isDown && cursors.down.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY(carVelocity)
        } else if (cursors.left.isDown) {
            car.setVelocityX((carVelocity * -1))
        } else if (cursors.right.isDown) {
            car.setVelocityX(carVelocity)
        } else if (cursors.up.isDown) {
            car.setVelocityY((carVelocity * -1))
        } else if (cursors.down.isDown) {
            car.setVelocityY(carVelocity)
        } else {
            car.setVelocityX(0)
            car.setVelocityY(0)
        }    
        if (car.body.velocity.x > 0) {
            car.anims.play('printerRight', true)
        } else if (car.body.velocity.x < 0) {
            car.anims.play('printerLeft', true)
        } else if (car.body.velocity.y > 0) {
            car.anims.play('printerDown', true)
        } else if (car.body.velocity.y < 0) {
            car.anims.play('printerUp', true)
        }
    }
})

let Water = new Phaser.Class({
        Extends: Phaser.Scene,

        initialize: 

    function waterScene () { Phaser.Scene.call(this, { key: 'water', active: false })},

    preload: function () {

    },

    create: function () {
        let scoringActive
        this.time.addEvent({
            delay: 500,
            loop: false,
            callback: () => {
                scoringActive = true
            }
        })
        timer = this.time.addEvent({
            delay: 29000,
            loop: false,
            callback: () => {
                this.cameras.main.fadeOut(100, 255, 255, 255)
            }
        })

        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, (cam, effect) => {
            this.sound.play('engine')
            carVelocity = 250
            carPosX = duck.body.position.x,
            carPosY = duck.body.position.y,
            carVelX = duck.body.velocity.x,
            carVelY = duck.body.velocity.y
            this.scene.start('sewer')
        })

        this.physics.world.setBounds(0, 0, 3200, 1920);

        const map = this.make.tilemap({key: 'drive'});   
        const villageTiles = map.addTilesetImage('Serene_Village_48x48', 'Serene_Village_48x48')
        
        map.createLayer('Water Background', villageTiles)
        map.createLayer('Water Road', villageTiles)
        let CollisionLayer = map.createLayer('Water Footpath', villageTiles)
        let StarLayer = map.getObjectLayer('Sheep')['objects']

        let stars = this.physics.add.group()
          
        StarLayer.forEach(object => {
            let obj = stars.create(object.x, object.y, 'bread')
            obj.setSize(150, 150, true)
            obj.setScale(0.5)
        })

        duck = this.physics.add.sprite(carPosX, carPosY, 'duckSprite').setScale(2)
        duck.setSize(30, 30, true)

        this.anims.create({
            key: 'duckDown',
            frames: this.anims.generateFrameNumbers('duckSprite', { start: 3, end: 5 }),
            frameRate: 10,
            repeat: -1
        })

        this.anims.create({
            key: 'duckLeft',
            frames: this.anims.generateFrameNumbers('duckSprite', { start: 15, end: 17 }),
            frameRate: 10,
            repeat: -1
        })

        this.anims.create({
            key: 'duckRight',
            frames: this.anims.generateFrameNumbers('duckSprite', { start: 27, end: 29 }),
            frameRate: 10,
            repeat: -1
        })

        this.anims.create({
            key: 'duckUp',
            frames: this.anims.generateFrameNumbers('duckSprite', { start: 39, end: 41 }),
            frameRate: 10,
            repeat: -1
        })

        this.anims.create({
            key: 'duckStop',
            frames: [{ key: 'duckSprite', frame: 4 }],
            frameRate: 20
        })

        let balls = map.getObjectLayer('Beach Ball')['objects']
        let bushes = map.getObjectLayer('Bush')['objects']
        let cats = map.getObjectLayer('Cat')['objects']
        let chicks = map.getObjectLayer('Chicken')['objects']
        let dangers = map.getObjectLayer('Sign')['objects']
        let foxes = map.getObjectLayer('Fox')['objects']
        let beetroots = map.getObjectLayer('Radishes')['objects']
        let carrots = map.getObjectLayer('Carrots')['objects']
        let cucumbers = map.getObjectLayer('Cucumber')['objects']
        let tomatoes = map.getObjectLayer('Tomatoes')['objects']
        let pigs = map.getObjectLayer('Pig')['objects']
        let rabbits = map.getObjectLayer('Rabbit')['objects']
        let barrels = map.getObjectLayer('Waste')['objects']
        let shovels = map.getObjectLayer('Shovel')['objects']
        let trees = map.getObjectLayer('Tree')['objects']
        let cans = map.getObjectLayer('WateringCan')['objects']

        let stuff = this.add.group()
        let beachballs = this.physics.add.group()
        
        balls.forEach(object => { beachballs.create(object.x, object.y, 'beachball') })
        bushes.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'bush')) })
        cats.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'cat')) })
        chicks.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'chick').setScale(0.5)) })
        dangers.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'danger')) })
        foxes.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'fox')) })
        beetroots.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'beetroot')) })
        carrots.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'carrots')) })
        cucumbers.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'cucumbers')) })
        tomatoes.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'tomatoes')) })
        pigs.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'pig').setScale(0.5)) })
        rabbits.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'rabbit')) })
        barrels.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'barrel')) })
        shovels.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'shovel')) })
        trees.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'waterTree')) })
        cans.forEach(object => { stuff.add(this.add.image(object.x, object.y, 'wateringCan')) })
        
        stuff.setOrigin(0, 1)
        beachballs.setOrigin(0, 1)

        stuff.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                }
            })
        })
        
        this.physics.add.overlap(duck, beachballs, hitBall, null, this)
        
        map.setCollisionBetween(0, 923, true, 'Footpath')
        this.physics.add.collider(duck, CollisionLayer)
        this.physics.add.collider(beachballs, CollisionLayer)
        this.physics.add.overlap(duck, stars, hitStar, null, this)

        this.cameras.main.setBounds(0, 0, 3200, 1920);
        this.cameras.main.startFollow(duck);
        
        duck.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();

        let breadParticles = this.add.particles('bread')
    
        breadParticles.createEmitter({
            lifespan: 10000,
            speed: -200,
            quantity: 32,
            scale: { start: 1, end: 2},
            alpha: { start: 0.5, end: 0 },
            on: false,
            angle: { start: 0, end: 360, steps: 32 },
        })

        this.add.image(0, 0, 'scoreBackground').setScale(0.55, 0.65).setOrigin(0).setScrollFactor(0)
        this.add.image(40, 25, 'scoreCoin').setScale(0.6).setScrollFactor(0)
        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            scoreText = add.text(70, 12, score, { fontFamily: 'Fredoka One', fontSize: '25px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} }).setScrollFactor(0)
        }
    });


        function hitStar (duck, star) {
            this.sound.play('quack')
            star.disableBody(true, true)
            score += 10;
            breadParticles.emitParticleAt((duck.body.position.x + 70), (duck.body.position.y + 70))
            if (scoringActive) {
                scoreText.setText(score);
            }
            if (stars.countActive(true) === 10) {
                stars.children.iterate(function (child) {
                    child.enableBody(true, child.x, child.y, true, true);
                });
            }
        }

        function hitBall (duck, ball) {
            if (ball.body.velocity.x === 0 && duck.body.velocity.x > 0) {
                ball.body.velocity.x = 10
            } else if (ball.body.velocity.x === 0 && duck.body.velocity.x < 0) {
                ball.body.velocity.x = -10
            }
            if (ball.body.velocity.y === 0 && duck.body.velocity.y > 0) {
                ball.body.velocity.y = 10
            } else if (ball.body.velocity.y === 0 && duck.body.velocity.y < 0) {
                ball.body.velocity.y = -10
            }
            if (ball.body.velocity.x > 0 && ball.body.velocity.x < 300) {
                ball.body.velocity.x += 50
            } else if (ball.body.velocity.x < 0 && ball.body.velocity.x > -300) {
                ball.body.velocity.x -= 50
            } 
            if (ball.body.velocity.y > 0 && ball.body.velocity.y < 300) {
                ball.body.velocity.y += 50
            } else if (ball.body.velocity.y < 0 && ball.body.velocity.y > -300) {
                ball.body.velocity.y -= 50
            }
                ball.setBounce(0.8)
                ball.setCollideWorldBounds(true)
        }
        game.events.on('blur', () => {
            timer.paused = true
        })
        game.events.on('focus', () => {
            timer.paused = false
        })
    },

    update: function () { 
        if (cursors.left.isDown && cursors.up.isDown) {
            duck.setVelocityX((carVelocity * -1))
            duck.setVelocityY((carVelocity * -1))
        } else if (cursors.right.isDown && cursors.up.isDown) {
            duck.setVelocityX(carVelocity)
            duck.setVelocityY((carVelocity * -1))
        } else if (cursors.right.isDown && cursors.down.isDown) {
            duck.setVelocityX(carVelocity)
            duck.setVelocityY(carVelocity)
        } else if (cursors.left.isDown && cursors.down.isDown) {
            duck.setVelocityX((carVelocity * -1))
            duck.setVelocityY(carVelocity)
        } else if (cursors.left.isDown) {
            duck.setVelocityX((carVelocity * -1))
            duck.anims.play('duckLeft', true)
        } else if (cursors.right.isDown) {
            duck.setVelocityX(carVelocity)
            duck.anims.play('duckRight', true)
        } else if (cursors.up.isDown) {
            duck.setVelocityY((carVelocity * -1))
            duck.anims.play('duckUp', true)
        } else if (cursors.down.isDown) {
            duck.setVelocityY(carVelocity)
            duck.anims.play('duckDown', true)
        } else {
            duck.setVelocityX(0)
            duck.setVelocityY(0)
            duck.anims.play('duckStop', true)
        }     
    }
})

let Sewer = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize:

    function sewer () { Phaser.Scene.call(this, { key: 'sewer', active: false }) },

    preload: function () {

    },

    create: function () {
        let scoringActive
        this.time.addEvent({
            delay: 500,
            loop: false,
            callback: () => {
                scoringActive = true
            }
        })

        this.time.addEvent({
            delay: 14200,
            loop: false,
            callback: () => {
                rt.destroy()
                sewerItems.setAlpha(1)
                carVelocity = 550
                this.lights.enable()
                dragons.children.iterate(object => {
                    object.setVisible(true)
                })
                greenDragons.children.iterate(object => {
                    object.setVisible(true)
                })
            }
        })

        timer = this.time.addEvent({
            delay: 21300,
            loop: false,
            callback: () => {
                this.cameras.main.fadeOut(100, 255, 255, 255)
            }
        })

        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, (cam, effect) => {
            carVelocity = 250
            carPosX = car.body.position.x,
            carPosY = car.body.position.y,
            carVelX = car.body.velocity.x,
            carVelY = car.body.velocity.y
            this.scene.start('desert')
        })

        let camera = this.cameras.main;
        camera.setBackgroundColor('#2D313C')

        this.physics.world.setBounds(0, 0, 3200, 1920);
        const map = this.make.tilemap({key: 'drive'}); 

        const sewerTurn = map.addTilesetImage('SewerTileTurn', 'SewerTileTurn')
        const sewerStraight = map.addTilesetImage('SewerTileStraight', 'SewerTileStraight')
        const sewerTiles = [sewerTurn, sewerStraight]

        const tileset = map.addTilesetImage('roadEW', 'roadEW')
        const tileset2 = map.addTilesetImage('roadNE', 'roadNE')
        const allTiles = [tileset, tileset2]
        const backgroundTile = map.addTilesetImage('SewerBackground', 'SewerBackground')
        
        const roadLayer = map.createLayer('Sewer Road', sewerTiles)
        const pathLayer = map.createLayer('Sewer Footpath', sewerTiles)
        let RatLayer = map.getObjectLayer('Sheep')['objects']
        const backgroundLayer = map.createLayer('Sewer Background', backgroundTile)
        backgroundLayer.setAlpha(0.5)
        const dragonLayer = map.getObjectLayer('Dragons')['objects']
        const greenDragonLayer = map.getObjectLayer('GreenDragons')['objects']

        dragons = this.physics.add.group()
        dragonLayer.forEach(object => {
            dragons.create(object.x, object.y, 'redDragon').setScale(1).setVelocity(Phaser.Math.Between(-50, 50)).setBounce(1).setVisible(false).setSize(10, 10).setAlpha(0.7)
            dragons.create(object.x, object.y, 'redDragon').setScale(1).setVelocity(Phaser.Math.Between(-100, 100)).setBounce(1).setVisible(false).setSize(10, 10).setAlpha(0.7)
        })
        greenDragons = this.physics.add.group()
        greenDragonLayer.forEach(object => {
            greenDragons.create(object.x, object.y, 'greenDragon').setScale(1.2).setVelocity(Phaser.Math.Between(-50, 50)).setBounce(1).setVisible(false).setSize(10, 10).setAlpha(0.7)
            greenDragons.create(object.x, object.y, 'greenDragon').setScale(1.2).setVelocity(Phaser.Math.Between(-100, 100)).setBounce(1).setVisible(false).setSize(10, 10).setAlpha(0.7)
        })

        let rats = this.physics.add.group()
        RatLayer.forEach(object => {
            let obj = rats.create(object.x, object.y, 'rat')            
            obj.setSize(50, 50, true)
            obj.setScale(1)
            obj.setOrigin(0,1)
        })

        
        backgroundLayer.setPipeline('Light2D');
        this.lights.enable();
        this.lights.setAmbientColor('#2D313C');
        light = this.lights.addLight(0, 0, 200);

        for (let i = 100; i < 3200; i+=400) {
        this.lights.addLight(i, 100, 240).setColor(0xff0000).setIntensity(3.0);
        this.lights.addLight(i, 200, 240).setColor(0x00ff00).setIntensity(3.0);
        this.lights.addLight(i, 300, 240).setColor(0xff00ff).setIntensity(3.0);
        this.lights.addLight(i, 400, 240).setColor(0xffff00).setIntensity(3.0);
        this.lights.addLight(i, 500, 240).setColor(0x00ffff).setIntensity(3.0);
        this.lights.addLight(i, 600, 240).setColor(0x0000ff).setIntensity(3.0);
        this.lights.addLight(i, 700, 240).setColor(0xff69b4).setIntensity(3.0);
        this.lights.addLight(i, 800, 240).setColor(0xff0000).setIntensity(3.0);
        this.lights.addLight(i, 900, 240).setColor(0x00ff00).setIntensity(3.0);
        this.lights.addLight(i, 1000, 240).setColor(0xff00ff).setIntensity(3.0);
        this.lights.addLight(i, 1100, 240).setColor(0xffff00).setIntensity(3.0);
        this.lights.addLight(i, 1200, 240).setColor(0x00ffff).setIntensity(3.0);
        this.lights.addLight(i, 1300, 240).setColor(0x0000ff).setIntensity(3.0);
        this.lights.addLight(i, 1400, 240).setColor(0xff69b4).setIntensity(3.0);
        this.lights.addLight(i, 1500, 240).setColor(0xff00ff).setIntensity(3.0);
        this.lights.addLight(i, 1600, 240).setColor(0xffff00).setIntensity(3.0);
        this.lights.addLight(i, 1700, 240).setColor(0x00ffff).setIntensity(3.0);
        this.lights.addLight(i, 1800, 240).setColor(0x0000ff).setIntensity(3.0);
        this.lights.addLight(i, 1900, 240).setColor(0xff69b4).setIntensity(3.0);
        }

        this.lights.disable()

        const width = 3200
	    const height = 1920

        const rt = this.make.renderTexture({
            width,
            height
	    }, true)
        rt.fill(0x000000, 1)
        rt.setTint(0x0a2948)

        car = this.physics.add.image(carPosX, carPosY, 'gator')
        car.setSize(70, 70, true)

        let sewerItems = this.physics.add.group()

        let speakers = map.getObjectLayer('Speakers Right')['objects']
        let speakersLeft = map.getObjectLayer('Speakers Left')['objects']
        speakers.forEach(object => { sewerItems.add(this.add.image(object.x, object.y, 'speaker')) })
        speakersLeft.forEach(object => { sewerItems.add(this.add.image(object.x, object.y, 'speakerLeft')) })
        sewerItems.setOrigin(0, 1).setAlpha(0.7)

        sewerItems.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                }
            })
        })

        sewerItems.setAlpha(0)

        let CollisionLayer = map.createLayer('Footpath', allTiles)
        CollisionLayer.setAlpha(0)

        vision = this.make.image({
            x: car.x,
            y: car.y,
            key: 'vision',
            add: false
        })
        vision.scale = 0.2

        rt.mask = new Phaser.Display.Masks.BitmapMask(this, vision)
	    rt.mask.invertAlpha = true

        map.setCollisionBetween(0, 923, true, 'Footpath')
        this.physics.add.collider(car, CollisionLayer)
        this.physics.add.overlap(car, rats, hitRat, null, this)
        
        this.cameras.main.setBounds(0, 0, 3200, 1920);
        this.cameras.main.startFollow(car);
        
        car.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();

        this.physics.add.collider(dragons, CollisionLayer)
        this.physics.add.collider(greenDragons, CollisionLayer)
        this.anims.create ({
            key: 'dragonup',
            frames: this.anims.generateFrameNumbers('redDragon', { start: 0, end: 2 }),
            frameRate: 8,
            repeat: -1
        })

        this.anims.create ({
            key: 'dragonright',
            frames: this.anims.generateFrameNumbers('redDragon', { start: 3, end: 5 }),
            frameRate: 8,
            repeat: -1
        })

        this.anims.create ({
            key: 'dragondown',
            frames: this.anims.generateFrameNumbers('redDragon', { start: 6, end: 8 }),
            frameRate: 8,
            repeat: -1
        })

        this.anims.create ({
            key: 'dragonleft',
            frames: this.anims.generateFrameNumbers('redDragon', { start: 9, end: 11 }),
            frameRate: 8,
            repeat: -1
        })

        this.anims.create ({
            key: 'greenDragon',
            frames: this.anims.generateFrameNumbers('greenDragon', { start: 0, end: 5 }),
            frameRate: 8,
            repeat: -1
        })

        dragons.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(10, 35))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                }
            })
        })

        greenDragons.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(10, 35))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                }
            })
        })

        greenDragons.children.entries.forEach(dragon => {
                dragon.anims.play('greenDragon', true)
        })

        this.add.image(0, 0, 'scoreBackground').setScale(0.55, 0.65).setOrigin(0).setScrollFactor(0)
        this.add.image(40, 25, 'scoreCoin').setScale(0.6).setScrollFactor(0)
        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            scoreText = add.text(70, 12, score, { fontFamily: 'Fredoka One', fontSize: '25px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} }).setScrollFactor(0)
        }
    });

    let winSound = this.sound.add('slurp', {
        volume: 0.3,
    })

        function hitRat (gator, rat) {
            winSound.play()
            carVelocity += 20
            rat.disableBody(true, true)
            score += 10
            if (scoringActive) {
                scoreText.setText(score);
            }
        }

        game.events.on('blur', () => {
            timer.paused = true
        })
        game.events.on('focus', () => {
            timer.paused = false
        })
    },

    update: function () {
        if (vision){
		vision.x = car.x
		vision.y = car.y
	}
        if (cursors.left.isDown && cursors.up.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY((carVelocity * -1))
            car.angle = 305
        } else if (cursors.right.isDown && cursors.up.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY((carVelocity * -1))
            car.angle = 35
        } else if (cursors.right.isDown && cursors.down.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY(carVelocity)
            car.angle = 125
        } else if (cursors.left.isDown && cursors.down.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY(carVelocity)
            car.angle = 215
        } else if (cursors.left.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.angle = 260
        } else if (cursors.right.isDown) {
            car.setVelocityX(carVelocity)
            car.angle = 80
        } else if (cursors.up.isDown) {
            car.setVelocityY((carVelocity * -1))
            car.angle = 350
        } else if (cursors.down.isDown) {
            car.setVelocityY(carVelocity)
            car.angle = 170
        } else {
            car.setVelocityX(0)
            car.setVelocityY(0)
        } 
        this.lights.lights.forEach(function (currLight) {
            if (currLight.x < 3200) {
                currLight.x += Phaser.Math.Between(-50, 50)
            } else {
                currLight.x = 0
            }
            if (currLight.y < 1920) {
                currLight.y += Phaser.Math.Between(-50, 50)
            } else {
                currLight.y = 0
            }
    });
        dragons.children.entries.forEach(dragon => {
            if (dragon.body.velocity.x > 0) {
                dragon.anims.play('dragonright', true)
            } else if (dragon.body.velocity.x < 0) {
                dragon.anims.play('dragonleft', true)
            } else if (dragon.body.velocity.y > 0) {
                dragon.anims.play('dragondown', true)
            } else if (dragon.body.velocity.y < 0) {
                dragon.anims.play('dragonup', true)
            }
        })
        greenDragons.children.entries.forEach(dragon => {
            if (dragon.body.velocity.x > 0) {
                dragon.flipX = false
            } else if (dragon.body.velocity.x < 0) {
                dragon.flipX = true
            }
        })
    }
})

let Desert = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize:

    function desert () { Phaser.Scene.call(this, { key: 'desert', active: false }) },

    preload: function () {

    },

    create: function () {
        let scoringActive
        this.time.addEvent({
            delay: 500,
            loop: false,
            callback: () => {
                scoringActive = true
            }
        })

        this.time.addEvent({
        delay: 14200,
        loop: false,
        callback: () => {
            rainbowParticles.resume()
            carVelocity = 600
        }
        })

        timer = this.time.addEvent({
            delay: 21500,
            loop: false,
            callback: () => {
                this.cameras.main.fadeOut(100, 255, 255, 255)
            }
        })

        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, (cam, effect) => {
            carPosX = car.body.position.x,
            carPosY = car.body.position.y,
            carVelX = car.body.velocity.x,
            carVelY = car.body.velocity.y
            this.scene.start('sky')
        })

        let camera = this.cameras.main;

        this.physics.world.setBounds(0, 0, 3200, 1920);
        const map = this.make.tilemap({key: 'drive'}); 

        const desertTiles = map.addTilesetImage('desert', 'desert')
        const desertObjects = map.addTilesetImage('desertObjects', 'desertObjects')

        const tileset = map.addTilesetImage('roadEW', 'roadEW')
        const tileset2 = map.addTilesetImage('roadNE', 'roadNE')
        const allTiles = [tileset, tileset2]

        map.createLayer('Desert Background', desertTiles)
        const pathLayer = map.createLayer('Desert Footpath', desertTiles)

        const roadLayer = map.createLayer('Desert Road', desertTiles)
        
        
        map.createLayer('Desert Objects', desertObjects)
        let PyramidLayer = map.getObjectLayer('Desert Pyramids')['objects']
        let rainbowParticles = this.add.particles('rainbow')
        let pyramids = this.physics.add.group()
        PyramidLayer.forEach(object => {
            let obj = pyramids.create(object.x, object.y, 'pyramid') 
            obj.setOrigin(0,1)  
        })
        map.createLayer('Desert Mask', desertTiles)
        
        car = this.physics.add.sprite(carPosX, carPosY, 'camel').setScale(1.5)
        car.setSize(50, 50, true)
        

        let DartLayer = map.getObjectLayer('Sheep')['objects']
        
        let darts = this.physics.add.group()
        DartLayer.forEach(object => {
            let obj = darts.create(object.x, object.y, 'durry')            
            obj.setSize(50, 50, true)
            obj.setScale(0.6)
            obj.setOrigin(0,1)
        })

        this.anims.create({
            key: 'camelDown',
            frames: this.anims.generateFrameNumbers('camel', { start: 54, end: 56 }),
            frameRate: 10,
            repeat: -1
        })

        this.anims.create({
            key: 'camelLeft',
            frames: this.anims.generateFrameNumbers('camel', { start: 66, end: 68 }),
            frameRate: 10,
            repeat: -1
        })

        this.anims.create({
            key: 'camelRight',
            frames: this.anims.generateFrameNumbers('camel', { start: 78, end: 80 }),
            frameRate: 10,
            repeat: -1
        })

        this.anims.create({
            key: 'camelUp',
            frames: this.anims.generateFrameNumbers('camel', { start: 90, end: 92 }),
            frameRate: 10,
            repeat: -1
        })

        this.anims.create({
            key: 'camelStop',
            frames: [{ key: 'camel', frame: 55 }],
            frameRate: 20
        })

        pyramids.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                },
            })
        })

        let CollisionLayer = map.createLayer('Footpath', allTiles)
        CollisionLayer.setAlpha(0)
        
        map.setCollisionBetween(0, 923, true, 'Footpath')
        this.physics.add.collider(car, CollisionLayer)
        this.physics.add.overlap(car, darts, hitDart, null, this)
        
        this.cameras.main.setBounds(0, 0, 3200, 1920);
        this.cameras.main.startFollow(car);
        
        car.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();

        let smokeParticles = this.add.particles('smoke')
        smokeParticles.createEmitter({
            lifespan: 2000,
            quantity: 1,
            scale: { start: 1, end: 4},
            alpha: { start: 1, end: 0 },
            on: false
        })

        PyramidLayer.forEach(object => {
            rainbowParticles.createEmitter({
                x: object.x + 110,
                y: object.y - 230,
                lifespan: 2000,
                quantity: 1,
                scale: 0.2,
                alpha: { start: 0.2, end: 0 },
                speedY: -400,
                rotate: 90,
                frequency: 100,
                active: true,
                origin: {x: 0, y: 1}
            })
        })
        rainbowParticles.pause()
        
        this.add.image(0, 0, 'scoreBackground').setScale(0.55, 0.65).setOrigin(0).setScrollFactor(0)
        this.add.image(40, 25, 'scoreCoin').setScale(0.6).setScrollFactor(0)
        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            scoreText = add.text(70, 12, score, { fontFamily: 'Fredoka One', fontSize: '25px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} }).setScrollFactor(0)
        }
    });

        function hitDart (camel, cig) {
            this.sound.play('exhale')
            carVelocity += 10
            cig.disableBody(true, true)
            score += 10
            smokeParticles.emitParticleAt((car.body.position.x + 70), (car.body.position.y + 70))
            if (scoringActive) {
                scoreText.setText(score);
            }
        }

        game.events.on('blur', () => {
            timer.paused = true
        })
        game.events.on('focus', () => {
            timer.paused = false
        })
    },

    update: function () {
        if (cursors.left.isDown && cursors.up.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY((carVelocity * -1))
        } else if (cursors.right.isDown && cursors.up.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY((carVelocity * -1))
        } else if (cursors.right.isDown && cursors.down.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY(carVelocity)
        } else if (cursors.left.isDown && cursors.down.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY(carVelocity)
        } else if (cursors.left.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.anims.play('camelLeft', true)
        } else if (cursors.right.isDown) {
            car.setVelocityX(carVelocity)
            car.anims.play('camelRight', true)
        } else if (cursors.up.isDown) {
            car.setVelocityY((carVelocity * -1))
            car.anims.play('camelUp', true)
        } else if (cursors.down.isDown) {
            car.setVelocityY(carVelocity)
            car.anims.play('camelDown', true)
        } else {
            car.setVelocityX(0)
            car.setVelocityY(0)
            car.anims.play('camelStop', true)
        } 
    }
})

let Sky = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize:

    function sky () { Phaser.Scene.call(this, { key: 'sky', active: false }) },

    preload: function () {

    },

    create: function () {
        let scoringActive
        this.time.addEvent({
            delay: 500,
            loop: false,
            callback: () => {
                scoringActive = true
            }
        })

        timer = this.time.addEvent({
            delay: 13000,
            loop: false,
            callback: () => {
                this.cameras.main.fadeOut(100, 255, 255, 255)
            }
        })

        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, (cam, effect) => {
            this.scene.start('end')
        })

        let camera = this.cameras.main;
        camera.setBackgroundColor('#1AD1FF')

        this.add.image(200, 200, 'sun').setScrollFactor(0)
        this.add.image(0, 550, 'skyMid').setScrollFactor(0.1, 0)
        this.add.image(800, 550, 'skyMid').setScrollFactor(0.1, 0)
        this.add.image(0, 450, 'farground').setScrollFactor(0.25, 0)
        this.add.image(800, 450, 'farground').setScrollFactor(0.25, 0)
        this.add.image(0, 550, 'foreground').setScrollFactor(0.5, 0)
        this.add.image(800, 550, 'foreground').setScrollFactor(0.5, 0)

        this.physics.world.setBounds(0, 0, 3200, 1920);
        let map = this.make.tilemap({key: 'drive'}); 
        const skyTiles = map.addTilesetImage('clouds', 'clouds')
        rainbowParticles = this.add.particles('rainbowSection')
        rainbowParticlesY = this.add.particles('rainbowSectionY')

        const tileset = map.addTilesetImage('roadEW', 'roadEW')
        const tileset2 = map.addTilesetImage('roadNE', 'roadNE')
        const allTiles = [tileset, tileset2]

        const rainbowStraight = map.addTilesetImage('Seven-colors_(rainbow)', 'Seven-colors_(rainbow)')
        const rainbowCorner1 = map.addTilesetImage('Rainbow Corner 1', 'Rainbow Corner 1')
        const rainbowCorner2 = map.addTilesetImage('Rainbow Corner 2', 'Rainbow Corner 2')
        const rainbowTiles = [rainbowStraight, rainbowCorner1, rainbowCorner2]

        rainbowRoad = map.createLayer('Sky Road', rainbowTiles)
        rainbowRoad.forEachTile(tile => {
            tile.alpha = 0
        })

        const pathLayer = map.createLayer('Sky Path', skyTiles)
        let EggLayer = map.getObjectLayer('Sheep')['objects']
        let SpaceStationLayer = map.getObjectLayer('SpaceStations')['objects']
        let PlaneLayer = map.getObjectLayer('Planes')['objects']
        let JesusLayer = map.getObjectLayer('Jesus')['objects']

        let skyStuff = this.physics.add.group()
        SpaceStationLayer.forEach(object => {
            let obj = skyStuff.create(object.x, object.y, 'spaceStation')
            obj.setOrigin(0, 1)
            obj.setSize(10, 10)
        })
        JesusLayer.forEach(object => {
            let obj = skyStuff.create(object.x, object.y, 'jesus')
            obj.setOrigin(0, 1)
            obj.setSize(10, 10)
        })

        planes = this.physics.add.group()
        PlaneLayer.forEach(object => {
            let obj = planes.create(object.x, object.y, 'plane')
            obj.setOrigin(0, 1)
            obj.setVelocity(300).setBounce(1)
            obj.setSize(10, 10)
        })
        
        let eggs = this.physics.add.group()
        EggLayer.forEach(object => {
            let obj = eggs.create(object.x, object.y, 'egg')            
            obj.setSize(500, 500, true)
            obj.setScale(0.1)
            obj.setOrigin(0,1)
        })

        car = this.physics.add.sprite(carPosX, carPosY, 'bird').setScale(0.8)
        car.setSize(100, 100, true)

        this.anims.create({
            key: 'birdFlap',
            frames: this.anims.generateFrameNumbers('bird', { start: 0, end: 7 }),
            frameRate: 17.65,
            repeat: -1
        })

        car.anims.play('birdFlap', true)

        skyStuff.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                },
            })
        })

        planes.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                },
            })
        })

        let CollisionLayer = map.createLayer('Footpath', allTiles)
        CollisionLayer.setAlpha(0)
        
        map.setCollisionBetween(0, 923, true, 'Footpath')
        this.physics.add.collider(car, CollisionLayer)
        this.physics.add.overlap(car, eggs, hitEgg, null, this)

        this.physics.add.overlap(car, rainbowRoad, crossPath, null, this)
        this.physics.add.collider(planes, CollisionLayer)

        this.cameras.main.setBounds(0, 0, 3200, 1920);
        this.cameras.main.startFollow(car);
        
        car.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();
        
        let rainbowWin = this.add.particles('gold')
        rainbowWin.createEmitter({
            lifespan: 5000,
            quantity: 10,
            speed: -1000,
            scale: { start: 0.1, end: 0.5},
            alpha: { start: 0.4, end: 0 },
            on: false,
            angle: { start: 0, end: 360, steps: 10 },
            rotate: { start: 0, end: 360, steps: 10 }
        })
        
        this.add.image(0, 0, 'scoreBackground').setScale(0.55, 0.65).setOrigin(0).setScrollFactor(0)
        this.add.image(40, 25, 'scoreCoin').setScale(0.6).setScrollFactor(0)
        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            scoreText = add.text(70, 12, score, { fontFamily: 'Fredoka One', fontSize: '25px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} }).setScrollFactor(0)
        }
    });
    
    let winSound = this.sound.add('harp', {
        volume: 0.2,
    })

        function hitEgg (bird, egg) {
            winSound.play()
            carVelocity += 10
            egg.disableBody(true, true)
            score += 10
            rainbowWin.emitParticleAt((car.body.position.x + 70), (car.body.position.y + 70))
            if (scoringActive) {
                scoreText.setText(score);
            }
        }

        function crossPath (bird, path) {
            let tile = map.getTileAt(path.x, path.y, true, rainbowRoad)
            this.tweens.add({
                targets: tile,
                props: {
                    alpha: {value: 0.5, duration: 300, ease: 'Linear', yoyo: false, repeat: 0}
                },
            })
        }

        game.events.on('blur', () => {
            timer.paused = true
        })
        game.events.on('focus', () => {
            timer.paused = false
        })
    },

    update: function () {
        if (cursors.left.isDown && cursors.up.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY((carVelocity * -1))
            car.angle = 45
            car.setFlipX(false)
        } else if (cursors.right.isDown && cursors.up.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY((carVelocity * -1))
            car.angle = 315
            car.setFlipX(true)
        } else if (cursors.right.isDown && cursors.down.isDown) {
            car.setVelocityX(carVelocity)
            car.setVelocityY(carVelocity)
            car.angle = 45
            car.setFlipX(true)
        } else if (cursors.left.isDown && cursors.down.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setVelocityY(carVelocity)
            car.angle = 315
            car.setFlipX(false)
        } else if (cursors.left.isDown) {
            car.setVelocityX((carVelocity * -1))
            car.setFlipX(false)
            rainbowParticles.emitParticleAt((car.body.position.x + 0), (car.body.position.y + 50))
            car.angle = 0
        } else if (cursors.right.isDown) {
            car.setVelocityX(carVelocity)
            rainbowParticles.emitParticleAt((car.body.position.x + 0), (car.body.position.y + 50))
            car.setFlipX(true)
            car.angle = 0
        } else if (cursors.up.isDown) {
            car.setVelocityY((carVelocity * -1))
            rainbowParticlesY.emitParticleAt((car.body.position.x + 0), (car.body.position.y + 35))
        } else if (cursors.down.isDown) {
            car.setVelocityY(carVelocity)
            rainbowParticlesY.emitParticleAt((car.body.position.x + 0), (car.body.position.y + 35))
        } else {
            car.setVelocityX(0)
            car.setVelocityY(0)
            car.angle = 0
        } 
        planes.children.entries.forEach(plane => {
            if (plane.body.velocity.x > 0) {
                plane.flipX = false
            } else {
                plane.flipX = true
            }
        })
    }
})

let White = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize:

    function white () { Phaser.Scene.call(this, { key: 'white', active: false }) },

    create: function () {
        let camera = this.cameras.main;
        camera.setBackgroundColor('#ffffff')
    },
})

let End = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize:

    function end () { Phaser.Scene.call(this, { key: 'end', active: false }) },

    preload: function () {

    },

    create: function () {
        let rubyParticles = this.add.particles('ruby')
        rubyParticles.createEmitter({
            lifespan: 8000,
            frequency: 200,
            speed: 200,
            gravityY: 100,
            scale: 0.4,
            x: 400,
            y: -70,
            rotate: { start: 0, end: 360}
        })
        let coinParticles = this.add.particles('coin')
        coinParticles.createEmitter({
            lifespan: 8000,
            frequency: 200,
            speed: 200,
            gravityY: 100,
            scale: 0.4,
            x: 400,
            y: -70,
            rotate: { start: 0, end: 360}
        })

        let finishItems = this.add.group()

        let add = this.add
        WebFont.load({
        google: {
            families: [ 'Fredoka One' ]
        },
        active: function () {
            add.text(160, 100, 'YOU FINISHED!', { fontFamily: 'Fredoka One', fontSize: '62px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 6, offsetX: 3, color: 'white', fill: true} })
            add.text(300, 300, `Score: ${score}`, { fontFamily: 'Fredoka One', fontSize: '32px', fill: '#ff3333', stroke: '#ffffff', strokeThickness: 8, shadow: {offsetY: 4, offsetX: 2, color: 'white', fill: true} })
        }
    });

        this.add.image(220, 277, 'button').setScale(0.7).setOrigin(0)

        finishItems.add(this.add.image(100, 450, 'pig'))
        finishItems.add(this.add.image(700, 450, 'chick'))

        finishItems.children.entries.forEach(object => {
            this.tweens.add({
                targets: object,
                props: {
                    y: {value: `+=${(Phaser.Math.RND.sign() * Phaser.Math.Between(5, 25))}`, duration: 226, ease: 'Cubic', yoyo: true, repeat: -1}
                }
            })
        })
        let camera = this.cameras.main;
        camera.setBackgroundColor('#8CB7F2')
    },

    update: function () {
    }
})

var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 576,
        audio: {
            disableWebAudio: true
        },
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        },
        scene: [White, End, Sky, Desert, Sewer, Water, Cubicle, Village, City, Start]
    };

    var game = new Phaser.Game(config);

    </script>

</body>
</html>